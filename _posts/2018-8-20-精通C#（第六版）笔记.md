---
layout:     post                    # 使用的布局（不需要改）
title:      C#编程               # 标题 
subtitle:                          #副标题
date:       2018-8-20              # 时间
author:     LCY                      # 作者
header-img: img/cover/bing_14.JPG    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                              #标签
- 编程
---

# 第一章 .NET之道
.NET可以理解为 **运行库环境** 和 **基础类库**
概念：
+ COM: component object model, 组件对象模型
+ CLR: common language runtime, 公共语言运行库，主要为我们定位、加载和管理.NET类型
+ CTS: common type sytem, 公共类型系统，CTS完整的我描述了运行库所支持的所有可能的数据类型和编程结构，它指的是一个集合{类、接口、委托、枚举、结构}，每个类型又是一个集合{构造函数、终结器、静态构造函数、嵌套类型、操作符、属性、索引器、字段、只读字段、常量、事件}中的一些元素
+ CLS: common language specification, 公共语言规范
+ BCL: base class library, 基础类库，封装了各种基本类型，如线程、文件输入和输出、图形绘制以及与各种硬件设备的交互
+ 托管语言：C#/VB/C++/JS/F#
+ 托管代码: managed code，简单来说就是必须运行在.NET运行库下的代码成为托管代码

# 第二章 构建C#应用程序

使用visual studio常用功能
+ 解决方案资源管理器
+ class view工具
+ object browser工具
+ 代码的重构
+ 可视化构建类（class designer）
+ 集成的SDK开发文档或帮助（这一点很重要，是解决很多问题的关键）

# 第三章 C#核心编程I
## 3.1 一个简单的程序
```matlab
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class SimpleStringTest
    {
        static void Main(string[] args)
        {
            string a = "\u0068ello ";
            string b = "world";
            Console.BackgroundColor = System.ConsoleColor.Blue;
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(a + b);
            Console.WriteLine(a + b == "Hello World"); // == performs a case-sensitive comparison
            //Console.ReadKey();
            Console.ReadLine();
        }
    }
}
```
批处理测试代码：
```matlab
@echo off

rem A batch file for ConsoleApp1.exe
rem which captures the app's return value.

ConsoleApp1
@if "%ERRORLEVEL%"=="0" goto success

:fail 
 echo This application has failed
 echo return value=%ERRORLEVEL%
 goto end
:success
 echo This application has succeeded
 echo return value=%ERRORLEVEL%
 goto end
:end
 echo all done.
```
+ C#程序是区分字母大小写的程序设计语言，特别注意，同时养成良好的命名习惯，可以参考前面的博客
+ 若出现undefined symbols编译错误时，检查拼写是否错误
+ C#程序必须包含一个Main()方法，作为程序的入口，即使使用void返回，它也会隐形的返回0作为错误代码，作为程序成功执行的标志，它可以使用批处理代码来捕获

## 3.2 System.Environment类
## 3.3 System.Console类
关于类的属性、方法、事件等使用方法和内容，可以直接查看msdn，其中有详细的内容

### 3.3.1 格式化数值数据
+ 可以单独使用`{}`进行占位输出，同时不需要按照递增的次序
+ 也可以使用数值格式字符，如下表所示，调用格式 `{0:f7}、{1:d2}`

字符串格式 | 作用
----|----
c/C |格式化货币
d/D | 用于格式化十进制数
e/E | 用于指数格式化
f/F | 用于浮点数

示例：
```matlab
static void FormatNumericalData()
{
    Console.WriteLine("The value 99999 in various formats:");
    Console.WriteLine("c format: {0:c}", 99999);
    Console.WriteLine("d9 format: {0:d9}", 99999);
    Console.WriteLine("f3 format: {0:f3}", 99999);
    Console.WriteLine("n format: {0:n}", 99999);

    // Notice that upper- or lowercasing for hex
    // determines if letters are upper- or lowercase.
    Console.WriteLine("E format: {0:E}", 99999);
    Console.WriteLine("e format: {0:e}", 99999);
    Console.WriteLine("X format: {0:X}", 99999);
    Console.WriteLine("x format: {0:x}", 99999);
}
```
## 3.4 C#关键字
## 3.5 System.String类
+ 其中包括一些对字符串基本的操作，因为在编写程序的过程中，经常需要使用到对字符串操作的方法，这一部分内容需要重要掌握
+ 理解字符串的 **不可变性**，使用方法处理后的字符串是一个新的字符串变量，如果输出处理前的变量，依然是不变的

## 3.6 窄化和宽化数据类型转换
## 3.7 隐式类型本地变量
主要就是关键字（其实算不上关键字）`var`的使用，使用它作为变量名也是不会出错的，所以它算不上是c#中的一个关键字

## 3.8 C#的迭代结构
+ for结构
+ foreach结构
+ while和do/while结构
可以配合`continue/break/goto`等关键字实现更加复杂的程序功能,语言集成查询`(LINQ):language integrated query` 

## 3.9 条件结构和关系/相等操作符
+ if/else语句
+ switch语句
当分支结果比较多的情况下，可以优先考虑使用switch语句结构

# 第四章 C#核心编程II
## 4.1 方法和参数修饰符
+ 静态方法可以被直接调用，无需创建类的实例

```matlab
class Program
{static in Add(int x, int y){return x+y}}
```

+ C#参数修饰符包括 `（无）\out\ref\params`

### 4.1.1 默认的参数传递行为
*note*：参数传入函数的默认行为是 **按值传递**，如果在成员的作用于内修改参数的值，改变的就是调用镇数据值得 **副本** 。
```matlab
static void Main(string[] args)
{
    int x = 10;
    int y = 20;
    Console.WriteLine("before call: x={0},y={1}", x, y);
    Console.WriteLine("answer is:{0}", Add(x, y));
    Console.WriteLine("before call: x={0},y={1}", x, y);
    Console.ReadLine();
    
    //return -1;
}
static int Add(int x, int y)
{
    int ans = x + y;
    x = 1; y = 2;
    return ans;
}
```
运行结果：
```matlab
before call: x=10,y=20
answer is:30
before call: x=10,y=20
```

### 4.1.2 out修饰符
*note*：它存在的主要意义在于调用者只使用一次方法调用就能获得 **多个返回值**。
```matlab
static void FillTheseValues(out int a, out sting b, out bool c)
{a=9;b="liaochengyu";c=false;}
```

### 4.1.3 ref修饰符
*note*：如果希望方法可以对在调用者作用域中声名的不同数据进行操作，例如排序和交换例程中，就必须使用引用参数
```matlab
static void Main(string[] args)
{
    int x = 10;
    int y = 20;
    Console.WriteLine("before call: x={0},y={1}", x, y);
    Console.WriteLine("answer is:{0}", Add(ref x, ref y));
    Console.WriteLine("before call: x={0},y={1}", x, y);
    Console.ReadLine();
    
    //return -1;
}
static int Add(ref int x, ref int y)
{
    int ans = x + y;
    x = 1; y = 2;
    return ans;
}
```

运行结果：
```matlab
before call: x=10,y=20
answer is:30
before call: x=1,y=2//原始数据已经发生了改变
```

### 4.1.4 params修饰符
*note*：为了避免歧义，c#要求方法只支持一个params参数，而且必须是参数列表中的最后一个参数。

### 4.1.5 定义可选参数
*note*：这项技术允许方法的调用者不指定不必要的参数，而是使用这些参数的默认值。同时，分配给可选参数的值必须在编译的时候确定。

### 4.1.6 使用命名参数调用方法
*note*：可选参数和命名参数往往会一起使用。

### 4.1.7 成员重载
*note*：**重载**，简而言之，当我们定义了一组名字相同的成员时，如果他们的参数数量或者类型不同，这样的成员就叫做被重载。

```matlab
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("***** Fun with Method Overloading *****\n");
        // Calls int version of Add()
        Console.WriteLine(Add(10, 10));
        // Calls long version of Add()
        Console.WriteLine(Add(900000000000, 900000000000));
        // Calls double version of Add()
        Console.WriteLine(Add(4.3, 4.4));
        Console.ReadLine();
    }
    #region Overloaded Add() method
    // Overloaded Add() method.
    static int Add(int x, int y)
    { return x + y; }
    static double Add(double x, double y)
    { return x + y; }
    static long Add(long x, long y)
    { return x + y; }
    #endregion
}
```

## 4.2 C#数组
### 4.2.1 C#数组的初始化语法
*note*：`string[] str=new string[] {"liao","cheng","yu"}`，使用`{}`语法时，不需要指定数组的大小。

### 4.2.2 隐式类型本地数组
*note*：隐式语法分配数组的时候，数组的初始化列表中每一项的类型都应该是相同的，默认不是`system.object`。

### 4.2.3 定义object数组
*note*：system.object是.NET类型系统中所有类型的最终积累，基于这一点，如果定义object数组，子项就可以是任何东西。

### 4.2.4 使用多维数组
*note*：C#支持两种多维数组，主要是区分他们 **初始化**的方式，以及使用的范围
+ 矩形数组，它只是一个每一行长度都相同的多维数组
`int[,] matrix=new int[6,2]`

+ 交错数组，包含一些内部数组，每一个都有各自的上界
`int[][] matrix=new int[5][]`

### 4.2.5 数组作为参数和返回值
### 4.2.6 system.Array基类
*note*：注意，system.array的很多成员都是定义为静态方法，因此可以在类级别进行调用。sytem.array的其他方法如：length属性绑定在对象级别上，因此我们可以直接在数组上调用成员。

## 4.3 枚举类型
### 4.3.1 控制枚举类型的底层存储
*note*：自定义枚举类型，元素之间使用`,`进行分隔，同时默认编号从`0`开始，当然也可以自己指定或者不连续，也不需要有唯一值。默认为`int`型，可以根据实际的需要更改数据类型，如`short、long、byte`等
```matlab
enum EmpType:byte(类型)
{
    Manager,       // = 0
    Grunt,         // = 1
    Contractor,    // = 2
    VicePresident  // = 3
}
```

### 4.3.2 声名枚举变量
### 4.3.3 system.enum类型
*note*：
+ 如果有实例，可以使用`GetType()`来获取对象的类型
+ 如果没有实例，也可以使用`typeof()`操作符来获取类型

## 4.4 结构类型(struct)
*note*：结构类型很适合在应用程序中对数学、集合以及其他“原子”实体建模。而且和枚举类型是比较相似的。它的使用类似于类的使用，也可以使用构造函数进行新建对象。

## 4.5 值类型和引用类型
## 4.6 C#可空类型
*note*：在涉及数据库编程时，可空数据类型可能特别的有用，因为一个数据表中的列可能有意是空的。

+ 4.6节测试代码：
```matlab
#region A class with nullable data
class DatabaseReader
{
    // Nullable data field.
    public int? numericValue = null;
    public bool? boolValue = true;

    // Note the nullable return type.
    public int? GetIntFromDatabase()
    { return numericValue; }

    // Note the nullable return type.
    public bool? GetBoolFromDatabase()
    { return boolValue; }
}
#endregion

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("***** Fun with Nullable Data *****\n");
        DatabaseReader dr = new DatabaseReader();

        int myData = dr.GetIntFromDatabase() ?? 100;
        Console.WriteLine("Value of myData: {0}", myData);

        // Get int from "database".
        int? i = dr.GetIntFromDatabase();
        if (i.HasValue)
            Console.WriteLine("Value of 'i' is: {0}", i.Value);
        else
            Console.WriteLine("Value of 'i' is undefined.");

        // Get bool from "database".
        bool? b = dr.GetBoolFromDatabase();
        if (b != null)
            Console.WriteLine("Value of 'b' is: {0}", b.Value);
        else
            Console.WriteLine("Value of 'b' is undefined.");
        Console.ReadLine();
    }

    #region Declaring nullable varaibles
    static void LocalNullableVariables()
    {
        // Define some local nullable types.
        int? nullableInt = 10;
        double? nullableDouble = 3.14;
        bool? nullableBool = null;
        char? nullableChar = 'a';
        int?[] arrayOfNullableInts = new int?[10];

        // Error! Strings are reference types!
        // string? s = "oops";
    }

    static void LocalNullableVariablesUsingNullable()
    {
        // Define some local nullable types using Nullable<T>.
        Nullable<int> nullableInt = 10;
        Nullable<double> nullableDouble = 3.14;
        Nullable<bool> nullableBool = null;
        Nullable<char> nullableChar = 'a';
        Nullable<int>[] arrayOfNullableInts = new int?[10];
    }
    #endregion
}
```

# 第五章 封装
